=head1 NAME

Module::UseFrom - Safe compile-time module loading from a variable

=head1 SYNOPSIS

 use Module::UseFrom;
 BEGIN {
   our $var = 'Scalar' . '::' . 'Util';
 }
 use_from $var; # use Scalar::Util;

=head1 DESCRIPTION

Many people have written about Perl's problem of loading a module from a string. This module attempts to solve that problem in a safe and useful manner. Using the magic of L<Devel::Declare>, the contents of a variable are translated into a bareword C<use> statement. Since C<Module::UseFrom> leans on this, the safest of the loading mechanisms, it should be every bit as safe. Even if the translations/hueristics used internally should fail, the system is not exposed to the insecurities introduced when translating to C<require FILE> statments or wrapping in a string C<eval>. 

Further, C<Module::UseFrom> can do some rudimentary checking before writing the C<use> statement. Most usefully, it can be told only to write the C<use> statement if the module is installed or even of a high enough version. 

=head1 FUNCTIONS 

C<Module::UseFrom> exports C<use_from> by default. Any of the following functions may be requested in the usual manner. The tag C<:all> will request them all.

=head2 use_from

The function C<use_from> is the basic interface provided by C<Module::UseFrom>. It takes one scalar variable, called WITHOUT round braces. C<Module::UseFrom> will inspect the variable for information. This variable must be a simple scalar (i.e. not a reference).

The most basic usage is as follows:

 use Module::UseFrom;
 BEGIN {
   our $var = 'Scalar::Util';
 }
 use_from $var; # use Scalar::Util;

If you need to import or specify a version, just do it as you would have if this was a simple C<use> call where your variable replaces the module:

 use Module::UseFrom;
 BEGIN {
   our $var = 'Scalar::Util';
 }
 use_from $var qw/dualvar/; # use Scalar::Util qw/dualvar/;

Some things to keep in mind:

=over

=item *

The variable must follow C<use_from> on the same line. This is a limitation stemming from L<Devel::Declare>.

=item *

The C<use_from> injects a C<use> statement taking the place of the original call and variable. This means if anything else exists on the same line or if the statement continues to further lines, it is left intact (even the ending semicolon is not affected). This behavior is by design, allowing the user to pass version or import directives as if C<use_from $var> was simply a regular C<use Bareword::Module> statement.

=item *

Since L<Devel::Declare> and C<use> both do their work at compile-time, your variable must be populated by then. C<BEGIN> blocks allow you to do this. 

=item *

C<Module::UseFrom> examines the given variable's contents, therefore the variable must be accessible from outside the package, this usually will mean using an C<our> variable.

=back

=head2 use_if_available

C<use_if_available> is called in the same way as C<use_from>, however unlike that function, it checks to see if the module is available before injecting the C<use> statement. Further if it detects a version declaration following the variable, it will only inject the C<use> statement if the version restriction can be satisfied.

To check if the module was C<use>ed, you may examine your original value in numeric context, which will contain the version as determined by L<Module::CoreList> or L<ExtUtils::Installed> (for core or non-core modules respectively) or C<0> if the module is not found.

 use Module::UseFrom 'use_if_available';
 our $var; # declared outside BEGIN for later inspection
 BEGIN {
   $var = 'Scalar::Util';
 }
 use_if_available $var 999 qw/reftype/; # Scalar::Util is not loaded

 die "I guess I really wanted $var" unless $var > 0;

Unlike C<use_from>, which naively injects the proper C<use> statement in-place, C<use_if_available> is smarter and will inject a list-prototyped no-op call in front of any import list should the module not be available or not of the proper version. If you don't know what this means, don't fret, just know that C<use_if_available> behaves as you think it should.

=head1 VERBOSE OUTPUT

Verbose output is controlled by the package variable C<$Module::UseFrom::verbose>.

When set to a true value, some additional information is printed to C<STDERR> (via C<warn>). In the special case that it is set to a reference to a scalar, the information is kept in that scalar rather than printing. Activating this feature will most likely need to be performed inside a C<BEGIN> block, so that it is set in time to be useful.

=head1 INSTALLATION ISSUES

During installation, one may see warnings like C<Name "ExtUtils::Packlist::FY1" used only once: possible typo at ...>. This seems to be related to L<ExtUtils::Installed> bug L<50315|https://rt.cpan.org/Public/Bug/Display.html?id=50315>. A L<patch|https://rt.perl.org/rt3//Public/Bug/Display.html?id=107410> has been accepted which should fix it. It is not a concern and does not affect any functionality whatsoever, just ignore it.

=head1 SOURCE REPOSITORY

L<http://github.com/jberger/Module-UseFrom>

=head1 AUTHOR

Joel Berger, E<lt>joel.a.berger@gmail.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2012 by Joel Berger

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.


